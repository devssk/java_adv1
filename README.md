김영한의 실전 자바 고급-1

멀티태스킹을 위해 여러 스레드작업을 하던 도중 스레드A의 작업을 잠시 멈추고 스레드 B를 실행해야 한다.
이 때 스레드 A의 코드가 어디까지 수행되었는지 위치라던가 계산하던 변수의 값을 메모리에 저장하고 다시 실행될때 불러들어야 한다.
이런 과정을 컨텍스트 스위칭이라고 한다.
멀티스레드는 대부분 효율적이지만 컨텍스트 스위칭 과정이 필요하므로 항상 효율적인 것은 아니다.


Thread 클래스 상속 방식
#### 장점
- 간단한 구현 : Thread 클래스를 상속받아 run() 클래스만 재정의하면 된다.
#### 단점
- 상속의 제한 : 자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속받고 있는 경우 Thread 클래스를 상속받을 수 없다.
- 유연성 부족 : 인터페이스를 사용하는 방법에 대해 유연성이 떨어진다.

Runnable 인터페이스 구현 방식
#### 장점
- 상속의 자유로움 : Runnable 인터페이스 방식은 다른 클래스를 상속받아도 문제없이 구현할 수 있다.
- 코드의 분리 : 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
- 여러 스레드가 동일한 Runnable을 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.
#### 단점
- 코드가 약간 복잡해질 수 있다. Runnable 객체를 생성하고 이를 Thread에 전달하는 과정이 추가된다.

스레드와 실행할 작업을 명확히 분리하고, 인터페이스를 사용하므로 클래스를 상속받는 방식보다 더 유연하고 유지보수 하기 쉬운 코드를 만들 수 있다.

스레드 간 실행 순서는 보장되지 않는다. -> 멀티스레드

데몬스레드 백그라운드에서 보조적인 작업을 수행, 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료됨 -> JVM이 데몬 스레드의 실행 완료를 기다리지 않고 종료

스레드 생성 시 스레드의 이름 전달 가능
```java
Thread thread = new Thread(new Runnable(), "myThread");
```
- runnable 인터페이스 구현체와 스레드 이름 전달, 이름을 생략하면 `Thread-0`, `Thread-1`등 임의의 이름 생성
- 스레드 객체 정보 : `thread.toString()` 스레드 ID, 스레드 이름, 스레드 우선순위, 스레드 그룹을 포함하는 문자열 반환
- 스레드 ID : 스레드의 고유 식별자, JVM 내에서 각 스레드에 대해 유일한 값, 스레드가 생성될 때 할당되며 직접 지정 불가
- 스레드 이름 : 스레드 이름은 중복 가능
- 스레드 우선 순위 : 1(가장낮음)부터 10(가장높음) 까지의 값 설정 가능, 기본 설정은 5, 스레드 스케줄러가 어떤 스레드를 우선 실행할지 결정되나 실제 실행 순서는 JVM 구현과 운영체제에 따라 달라질 수 있다.
- 스레드 그룹 : 그룹화하여 관리할 수 있는 기능 제공, 부모 스레드와 동일한 스레드 그룹에 속한다.
  - 부모 스레드 : 새로운 스레드를 생성하는 스레드를 의미, 스레드는 기본적으로 다른 스레드에 의해 생성되므로 새로 생성한 스레드를 부모로 간주
  - 스레드 그룹기능은 직접적으로 잘 사용하지는 않음

스레드 상태
- 새로운 상태
  - NEW : 스레드가 아직 시작되지 않은 상태
- 실행 가능 상태
  - RUNNABLE () : 스레드가 실행 중이거나 실행될 준비가 된 상태
- 일시 중지 상태들 (Suspended States) -> 기다리는 상태를 묶기 위한 용어일뿐 실제 상태 용어가 아님
  - BLOCKED : 스레드가 동기화 락을 기다리는 상태
  - WAITING : 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태
  - TIMED_WAITING : 일정 시간 동안 시다리는 상태
- 종료 상태
  - TERMINATED : 스레드가 실행을 마친 상태

NEW
- 스레드가 생성되고 아직 시작되지 않은 상태
- Thread 객체가 생성되었으나 start() 메서드가 호출되지 않은 상태

RUNNABLE
- 스레드가 실행될 준비가 된 상태
- 이 상태에서 스레드는 실제로 CPU에서 실행될 수 있다.
- start() 메서드가 호출되면 이상태가 됨
- RUNNABLE상태에 있는 모든 스레드가 동시에 실행되는것은 아님 -> 운영체제의 스케줄러가 각 스레드에 CPU시간을 할당하여 실행하기 때문에 이 상태의 스레드는 스케줄러의 실행 대기열에 포함되어 있다가 차례로 CPU에서 실행
- 운영체제의 스케줄러의 실행 대기열에 있든, CPU에서 실제 실행되고 있는 모두 RUNNABLE 상태, 자바에서 구분할수 없음
- 보통 실행 상태 라고 부름

BLOCKED
- 스레드가 다른 스레드에 의해 동기화 락을 얻기 위해 기다리는 상태
- 예를 들어 synchronized 블록에 진입하기 위해 락을 얻어야 할 경우

WAITING
- 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태
- wait(), join() 메서드가 호출될 때 이 상태
  - join() 을 호출하는 스레드는 대상 스레드가 TERMINATED 상태가 될 때 까지 대기
  - 대상 스레드가 TERMINATED 상태가 되면 호출 스레드는 다시 RUNNABLE 상태가 되면서 다음 코드를 수행
- 스레드는 다른 스레드가 notify() 또는 notifyAll() 메서드를 호출하거나 join()이 완료될 때까지 기다림

TIMED WAITING
- 스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태
- sleep(long millis), wait(long timeout), join(long millis) 메서드가 호출될 때 이 상태
- 주어진 시간이 경과하거나 다른 스레드가 해당 스레드를 깨우면 이 상태에서 벗어남

TERMINATED
- 스레드의 실행이 완료된 상태
- 스레드가 정상적으로 종료되거나 예외가 발생하여 종료된 경우 이 상태
- 스레드는 한 번 종료되면 다시 시작할 수 없다.

자바 스레드 상태 전이 과정
- NEW -> RUNNABLE : start() 호출하면 스레드가 RUNNABLE 상태로 전이
- RUNNABLE -> BLOCKED/WAITING/TIMED WAITING : 스레드가 락을 얻지 못하거나 wait() 또는 sleep()를 호출할 때 해당 상태로 전이
- BLOCKED/WAITING/TIMED WAITING -> RUNNABLE : 스레드가 락을 얻거나, 기다림이 완료되면 다시 RUNNABLE 상태로 돌아감
- RUNNABLE -> TERMINATED : 스레드의 run() 메서드가 완료되거나 예외가 발생하여 종료될 경우 TERMINATED 상태가 된다

자바에서 메서드를 재정의 할 때 재정의 메서드가 지켜야할 예외와 관련된 규칙이 있다.
- 체크 예외
  - 부모 메서드가 체크 예외를 던지지 않는 경우, 재정의된 자식 메서드도 체크 예외를 던질 수 없다.
  - 자식 메서드는 무로 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.
- 언체크(런타임) 예외
  - 예외 처리를 강제하지 않으므로 상관없지 던질 수 있다.

Runnable 인터페이스의 run() 메서드는 아무런 체크 예외를 던지지 않는다. 따라서 Runnable 인터페이스의 run() 메서드를 재정의 하는 곳에서는 체크 예외를 밖으로 던질 수 없다.

자바가 이런 제약을 두는 이유

부모 클래스의 메서드를 호출하는 클라이언트 코드는 부모 메서드가 던지는 특정 예외만을 처리하도록 작성됨. 자식 클래스가 더 넓은 범위의 예외를 던지면 해당 코드는 모든 예외를 제대로 처리하지 못할 수 있다. 이는 예외 처리의 일관성을 해치고 예상하지 못한 런타임 오류를 초래할 수 있기 때문

안전한 예외처리
- 체크 예외를 run() 메서드에서 던질 수 없도록 강제함으로써, 개발자는 반드시 체크예외를 try-catch 블록 내에서 처리하게 된다.
- 이는 예외 발생 시 예외가 적절히 처리 되지 않아서 프로그램이 비정상 종료되는 상황을 방지
- 특히 멀티스레딩 환경에서는 예외 처리를 강제함으로써 스레드의 안정성과 일관성을 유지할 수 있다.
- 다만 체크 예외를 강제하는 이런 부분들은 자바 초창기 기조이고, 최근에는 언체크(런타임) 예외를 선호한다.

this
- 어떤 메서드를 호출하는 것은, 특정 스레드가 어떤 메서드를 호출하는 것
- 스레드는 메서드의 호출을 관리하기 위해 메서드 단위로 스택 프레임을 만들고 해당 스택 프레임을 스택위에 쌓아 올린다.
- 이때 인스턴스의 메서드를 호출하면 어떤 인스턴스의 메서드를 호춯했는지 기억하기 위해 해당 인스턴스의 참조값을 스택 프레임 내부에 저장해준다.
- 이것이 바로 this -> 호출된 인스턴스 메서드가 소속된 객체를 가리키는 참조

인터럽트
- 특정 스레드의 인스턴스에 interrupt() 메서드를 호출하면 해당 스레드에 인터럽트 발생
- 인터럽트가 발생하면 해당 스레드에 InterruptedException 발생 -> sleep() 같은 체크예외를 쓸때
  - 인터럽트를 받은 스레드는 대기 상태에서 깨어나 RUNNABLE 상태가 되고 코드를 정상 수행
  - InterruptedException 을 Catch로 잡아서 정상 흐름으로 변경
- interrupt() 를 호출한다고 해서 즉각 InterruptedException 이 발생하는 것은 아님
  - Thread.sleep() 처럼 InterruptedException 을 던지는 메서드를 호출 하거나 호출하며 대기중일 대 예외가 발생
- 자바에서 인터럽트가 한번 발생하면 스레드의 인터럽트 상태를 다시 정상(false)로 돌려야 한다.
  - 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생
  - 인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.
  - InterruptedException 예외가 한번 발생하면 스레드의 인터럽트 상태를 다시 정상(false)로 돌림
  - 최대한 빨리 스레드를 종료해야 한다면 해당 스레드를 다시 인터럽트 상태로 변경하는 경우도 있음


- 스레드의 인터럽트 상태를 단순히 확인만 하는 용도라면 isInterrupted()
- 직접 체크해서 사용할때는 Thread.interrupted() 사용
  - 스레드가 인터럽트 상태라면 true 를 반환하고 해당 스테드의 인터럽트 상태를 false 로 변경
  - 스레드가 인터럽트 상태가 아니라면 flase 를 반환하고 해당 스레드의 인터럽트 상태를 변경하지 않음

yield - 양보하기
- 어떤 스레드를 얼마나 실행할지는 운영체제가 스케줄링을 통해 결정
- 특정 스레드가 크게 바쁘지 않은 상황이어서 다른 스레드에 CPU 실행 기회를 양보하고 싶을 수 있다.
- 이렇게 양보하면 스케줄링 큐에 대기 중인 다른 스레드가 CPU 실행 기회를 더 빨리 얻을 수 있다.

자바의 스레드가 RUNNABLE 상태일 때 운영체제의 스케줄링은 다음과 같은 상태들을 가질 수 있다
 - 실행 상태(Running) : 스레드가 CPU에서 실제로 실행 중이다.
 - 실행 대기 상태(Ready) : 스레드가 실행될 준비가 되었지만, CPU가 바빠서 스케줄링 큐에서 대기 중이다.
 - 운영체제는 실행 상태의 스레드들을 잠깐만 실행하고 실행 대기 상태로 만든다. 그리고 실행 대기 상태의 스레드들을 잠깐만 실행 상태로 변경해서 실행 한다. 이 과정을 계속 반복한다.
 - 자바에서는 두 상태를 구분할 수 없다.

yield()의 작동
- Thread.yield() 메서드는 현재 실핼 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될수 있도록 한다.
- yield() 메서드를 호출한 스데르는 RUNNABLE 상태를 유지하면서 CPU를 양보한다. 즉 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘긴다.
- 운영체제의 스케줄레에게 단지 힌트를 제공할 뿐, 강제적인 실행 순서를 지정하지 않는다.
- 또한 반드시 다른 스레드가 실행되는 것도 아니다.
  - 양보할 스레드가 없다면 본인 스레드가 계속 실행될 수 있다.

CPU는 처리 성능을 개선하기 위해 중간에 캐시 메모리라는것을 사용
- CPU <-> 메인 메모리 간의 거리가 멀고 속도도 상대적으로 느리다.
- CPU연산은 매우 빠르기 때문에 이에 따라가려면 매우 빠른 메모리가 필요한데 이게 캐시 메모리 이다.
- 스레드 각각 변수를 캐시 메모리에 불러와 보관.
  - 프로그램 시작 시점에는 모든 스레드에서 메인 메모리의 값을 읽고 캐시 메모리에 저장
  - 실행 도중 값이 변경되었을 경우 캐시 메모리의 값만 변경됨. 즉시 메인 메모리에 값이 반영되지 않음

캐시 메모리를 메인 메모리에 반영하거나, 메인 메모리의 변경 내역을 캐시 메모리에 다시 불러오는것은 언제 발생할까?
- CPU 설계 방식과 실행 환경에 따라 다를 수 있다.
- 즉시 반영될 수도 있고 몇 밀리초 이후 또는 몇 초후에 될 수도 있고 평생 반영되지 않을 수도 있다.
- 주로 컨텍스트 스위칭이 될 때 캐시 메모리도 함께 갱신되는데 환경에 따라 달라질 수 있다.

메모리 가시성
- 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를 메모리 가시성이라 한다.

캐시 메모리를 사용하면 CPU 처리 성능을 개선할 수 있다. 그러나 여러 스레드에서 같은 시점에 정확히 같은 데이터를 보는 것이 더 중요할 수 있다.
- 성능을 포기하는 대신에 값을 읽을 때, 값을 쓸 때 모두 메인 메모리에 직접 접근
  - volatile 이라는 키워드로 이런 기능을 제공


**Java Memory Model**
- 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정
- 멀티스레드 프로그래밍에서 스레드 간의 상호작용을 정의

**happens-before**
- 자바 메모리 모델에서 스레드간의 작업 순서를 정의하는 개념
- A 작업이 B 작업보다 이 관계에 있다면 A 작업에서의 모든 메모리 변경 사항은 B 작업에서 볼 수 있다.
- 즉 A 작업에서 변경된 내용은 B 작업이 시작되기 전에 모두 메모리에 반영 된다
  - 이름 그대로, 한 동작이 다른 동작보다 먼저 발생함을 보장
  - 스레드 간의 메모리 가시성을 보장하는 규칙
  - 이 관계가 성립하면 한 스레드의 작업을 다른 스레드에서 볼 수 있게 된다
  - 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태를 보장


synchronized
- 여러 스레드가 공유자원에 대해 일관성 있고 안전한 접근을 보장하기 위한 메커니즘
- 모든 객체(인스턴스)는 내부에 자신만의 lock을 가지고 있다.
  - 모니터 락이라고도 부른다
  - 객체 내부에 있고 우리가 확인하기는 어렵다.
- 스레드가 synchronized 키워드가 있는 메서드에 진입하려면 반드시 해당 인스턴스의 락이 있어야 한다.
  - 다른 스레드가 인스턴스에 있는 락 획득을 시도할 때 해당 인스턴스의 락이 없으면 락을 획득할 때 까지 BLOCKED 상태로 대기한다.
    - BLOCKED 상태에서는 CPU 스케줄링에 들어가지 않음
  - 락을 획득한 스레드는 BLOCKED -> RUNNABLE 상태가 되고 다시 코드를 실행
  - 락을 획득하는 순서는 보장되지 않는다.
- volatile을 사용하지 않아도 synchronized 안에서 접근하는 변수의 메모리 가시성 문제는 해결된다.
- 가장 큰 장점이자 단점은 한 번에 하나의 스레드만 실행할 수 있다는 점
  - 여러 스레드가 동시에 실행하지 못하기 때문에 전체로 보면 성능이 떨어질 수 있다.
  - 꼭 필요한 곳으로 한정해서 설정해야 한다.
- synchronized (this) {}로 코드 블럭으로 지정 가능
  - (this) -> 락을 획득할 인스턴스의 참조
- 무한 대기 : BLOCKED 상태의 스레드는 락이 풀릴 때 까지 무한 대기
  - 타임아웃 불가, 인터럽트 불가
- 공정성 : BLOCKED 상태의 여러 스레드 중에 어떤 스레드가 락을 획득할 지 알 수 없다.

LockSupport
- synchronized 의 가장 큰 문제인 무한대기를 해결
- 스레드를 WAITING 상태로 변경 -> CPU 실행 스케줄링에 들어가지 않음
- park() : 스레드를 WAITING 상태로 변경한다
  - 스레드를 대기 상태로 둔다
- parkNanos(nanos) : 스레드를 나노초 동안만 TIMED_WAITING 상태로 변경한다
  - 지정한 나노초가 지나면 TIMED_WAITING -> RUNNABLE
- unpark(thread) : WAITING 상태의 대상 스레드를 RUNNABLE 상태로 변경한다

BLOCKED vs WAITING
- 인터럽트
  - BLOCKED 상태는 인터럽트가 걸려도 대기 상태를 빠져나오지 못함
  - WAITING, TIMED_WAITING 상태는 인터럽트가 걸리면 대기 상태를 빠져나옴 -> RUNNABLE 상태로 변경
- 용도
  - BLOCKED 상태는 자바의 synchronized 에서 락을 획득하기 위해 대기할 때 사용
  - WAITING, TIMED_WAITING 상태는 스레드의 특정 조건이나 시간 동안 대기할 때 발생하는 상태
    - WAITING -> Thread.join(), LockSupport.park(), Object.wait() 등 메서드 호출 시
    - TIMED_WAITING -> Thread.sleep(ms), Object.wait(long timeout), Thread.join(long millis), LockSupport.park(ns) 등 시간 제한이 있는 메서드 호출 시

ReentrantLock
- 비공정 모드
  - 기본 모드, 락을 먼저 요청한 스레드가 락을 먼저 획득한다는 보장이 없음
  - 락을 풀었을 때 대기 중인 스레드 중 아무나 락을 획득할 수 있음
  - 락을 빨리 획득할 수 있지만 특정 스레드가 장기간 락을 획득하지 못할 가능성도 있음
  - 성능 우선 : 락을 획득하는 속도가 빠르다.
  - 선점 가능 : 새로운 스레드가 기존 대기 스레드보다 먼저 락을 획들할 수 있다.
  - 기아 현상 가능성 : 특정 스레드가 계속해서 락을 획득하지 못할 수 있다.
- 공정 모드
  - 생성자에 true 전달
  - 락을 요청한 순서대로 스레드가 락을 획득할 수 있게 한다.
  - 스레드 간 공정성 보장
  - 성능 저하가 일어날 수 있다.
  - 공정성 보장 : 대기 큐에서 먼저 대기한 스레드가 락을 먼저 획득한다.
  - 기아 현상 방지 : 모든 스레드가 언젠가 락을 획득할 수 있게 보장
  - 성능 저하 : 락을 획득하는 속도가 느려질 수 있다.
- void lock()
  - 락을 획득, 다른 스레드가 이미 락을 획득했다면 락이 풀릴 때까지 현재 스레드는 WAITING 상태
  - 인터럽트에 응답하지 않는다.
    - 정확히는 RUNNABLE 상태로 바뀌지만 다시 락을 획득할수 없으므로 WAITING상태로 다시 변경
  - void lockInterruptibly()
  - 락 획들을 시도하되, 다른 스레드가 인터럽트할 수 있다.
  - 대기중에 인터럽트가 발생하면 InterruptedException 발생하며 락 획득을 포기
- boolean tryLock()
  - 락 획득을 시도하고 즉시 성공여부 반환
  - 다른 스레드가 이미 락을 획득했다면 flase를 반환하고 그렇지 않으면 락을 획득하고 true 반환
- boolean tryLock(long time, TimeUnit unit)
  - 주어진 시간 동안 락 획득을 시도
  - 주어진 시간 안에 락을 획득하면 true 반환, 주어진 시간 동안 락을 획득하지 못하면 false 반환
  - 대기 중 인터럽트가 발생하면 InterruptedException 발생하며 락 획득을 포기
- void unlock()
  - 락을 해체한다.
  - 락 획득을 대기 중인 스레드 중 하나가 락을 획득할 수 있다.
  - 락을 획득한 스레드가 호출해야 하며 그렇지 않으면 IllegalMonitorStateException이 발생
- Condition newCondition()
  - Condition 객체를 생성하여 반환, 이 객체는 락과 결합되어 사용되며 스레드가 특정 조건을 기다리거나 신호를 받을 수 있도록 한다.
  - Object 클래스의 wait, notify, nofityAll 메서드와 유사한 역할을 함



- 생산자(Producer) : 데이터를 생성하는 역할, 파일에서 데이터를 읽어오거나 네트워크에서 데이터를 받아오는 스레드가 생산자 역할
- 소비자(Consumer) : 생성된 데이터를 사용하는 역할, 데이터를 처리하거나 저장하는 스레드가 소비자 역할
- 버퍼(Buffer) : 생산자가 생성한 데이터를 일시적으로 저장하는 공간, 이 버퍼는 한정된 크기를 가지며 생산자와 소비자가 이 버퍼를 통해 데이터를 주고 받음
- 생산자 소비자 문제 : 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제
- 한정된 버퍼 문제 : 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생하는 문제

Object - wait, notify
- synchronized 의 무한 대기 문제는 Object 클래스의 메서드를 활용해 해결할 수 있다.
- Object.wait()
  - 현재 스레드가 가진 락을 반납하고 대기한다.(WAITING)
  - 이 메서드는 현재 스레드가 synchronized 블록이나 메서드에서 락을 소유하고 있을때만 호출할 수 있다.
  - 호출한 스레든느 락을 반납하고, 다른 스레드가 해당 락을 획득할 수 있도록 한다.
  - 다른 스레드가 notify() 또는 notifyAll() 을 호출할 때 까지 대기 상태를 유지
- Object.notify()
  - 대기 중인 스레드 중 하나를 깨운다.
  - synchronized 블록이나 메서드에서 호출되어야 한다.
  - 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다. 대기 중인 스레드가 여러 개라면 그 중 하나만이 깨워진다.
- Object.notifyAll()
  - 대기 중인 모든 스레드를 깨운다.
  - synchronized 블록이나 메서드에서 호출되어야 한다.
  - 모든 대기 중인 스레드가 락을 획득할 수 있는 기회를 얻게 된다.
  - 모든 스레드를 깨워야 할 필요가 잇는 경우에 유용

스레드 대기 집합
- synchronized 안에서 Object.wait() 을 호출하면 스레드는 WAITING 상태에 들어간다.
- 이렇게 대기 상태에 들어간 스레드를 관리하는 것을 대기 집합이라 한다.
- 모든 객체는 각자의 대기 집합을 가지고 있다.
- 모든 객체는 모니터 락과 대기 집합을 가지고 있으며 둘은 한 쌍으로 사용된다.
  - 락을 획득한 객체의 대기 집합을 사용해야 한다.

Condition

`Condition condition = lock.newCondition();`
- condition은 ReentrantLock을 사용하는 스레드가 대기하는 스레드 대기 공간
- condition.await()
  - Object.wait() 과 유사한 기능, 지정한 condition에 현대 스레드를 WAITING 상태로 보관
  - ReentrantLock에서 획득한 락을 반납하고 대기 상태로 condition에 보관
- condition.signal()
  - Object.notify() 와 유사한 기능, 지정한 condition에서 대기중인 스레드를 하나 깨운다.
  - 깨어난 스레드는 condition에서 빠져나온다.


Object.notify() vs Condition.signal()
- Object.notify()
  - 대기 중인 스레드 중 임의의 하나를 선택해서 깨운다.
  - 스레드가 깨어나는 순서는 정의되어 있지 않다.
  - JVM구현에 따라 다르다. 보통은 먼저 들어온 스레드가 먼저 수행되지만 구현에 따라 다를 수 있다.
  - synchronized 블록 내에서 모니터 락을 가지고 있는 스레드가 호출해야 한다.
- Condition.signal()
  - 대기 중인 스레드 중 하나를 깨우며, 일반적으로는 FIFO 순서로 깨운다.
  - 자바 버전과 구현에 따라 달라질 수 있지만 보통 Condition의 구현은 Queue 구조를 사용하기 때문에 FIFO 순서로 깨운다.
  - ReentrantLock을 가지고 있는 스레드가 호출해야 한다.

synchronized 대기
- 대기 1 : 락 획득 대기
  - BLOCKED 상태로 락 획득 대기
  - synchronized 를 시작할 때 락이 없으면 대기
  - 다른 스레드가 synchronized 를 빠져나갈 때 대기가 풀리며 락 획득 시도
- 대기 2 : wait() 대기
  - WAITING 상태로 대기
  - wait() 를 호출 했을 때 스레드 대기 집합에서 대기
  - 다른 스레드가 notify() 를 호출 했을 때 빠져나감

BLOCKED 상태의 스레드들도 어딘가의 공간에서 자바가 관리한다.

자바의 모든 객체 인스턴스는 멀티스레드와 임계 영역을 다루기 위해 내부에 3가지 기본 요소를 가진다.
- 모니터 락
- 락 대기 집합(모니터 락 대기 집합)
- 스레드 대기 집합
- 락 대기 집합이 1차, 스레드 대기 집합이 2차 대기소라 생각하면 된다
- 2차 대기소에 들어간 스레드는 2차 -> 1차 대기소를 모두 빠져나와야 임계 영역을 수행할 수 있다.
- 정리
  - synchronized를 사용한 임계 영역에 들어가려면 모니터 락이 필요하다
  - 모니터 락이 없으면 락 대기 집합에 들어가서 BLOCKED 상태로 락을 기다린다.
  - 모니터 락을 반납하면 락 대기 집합에 있는 스레드 중 하나가 락을 획득하고 BLOCKED -> RUNNABLE 상태가 된다.
  - wait() 을 호출해서 스레드 대기 집합에 들어가기 위해서는 모니터 락이 필요하다.
  - 스레드 대기 집합에 들어가면 모니터 락을 반납한다.
  - 스레드가 notify()를 호출하면 스레드 대기 집합에 있는 스레드 중 하나가 스레드 대기 집합을 빠져나온다. 그 후 모니터 락 획득을 시도한다
    - 모니터 락을 획득하면 임계 영역을 수행한다.
    - 모니터 락을 획득하지 못하면 락 대기 집합에 들어가서 BLOCKED 상태로 락을 기다린다.

ReentrantLock 대기
- 대기 1 : ReentrantLock 락 획득 대기
  - ReentrantLock의 대기 큐에서 관리
  - WAITING 상태로 락 획득 대기
  - lock.lock() 을 호출 했을 때 락이 없으면 대기
  - 다른 스레드가 lock.unlock() 을 호출 했을 때 대기가 풀리며 락 획득 시도, 락을 획득하면 대기 큐를 빠져나감
- 대기 2 : await() 대기
  - condition.await() 을 호출 했을 때, condition 객체의 스레드 대기 공간에서 관리
  - WAITING 상태로 대기
  - 다른 스레드가 condition.signal() 을 호출 했을 때 condition 객체의 스레드 대기 공간에서 빠져나감


